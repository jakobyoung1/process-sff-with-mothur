# process-sff-with-mothur

## USING MOTHUR TO READ .DFF FILES

### If you have homebrew installed, run this
```
brew install g++ make zlib
```


### download the correct version of MOTHUR from here:
```
https://github.com/mothur/mothur/releases
```


### download SILVA database and taxonomy
```
wget https://mothur.s3.us-east-2.amazonaws.com/wiki/silva.seed_v138.tgz
```


### place your sff file and the SILVA files into the MOTHUR directory


### to create fasta and qual files:
```
sffinfo(sff=your_file.sff)
```


### align to SILVA database
```
align.seqs(fasta=your_file.trim.fasta, reference=silva.nr_v138.align)
```

### Gets a summary
```
summary.seqs(fasta=/Users/jakobyoung/Desktop/mothur/test.align)
```

### screen to make sure they fit length criteria
```
screen.seqs(fasta=/Users/jakobyoung/Desktop/mothur/test.align, start=1044, end=43116, minlength=200)
```

### remove chimeric sequences
```
chimera.vsearch(fasta=/Users/jakobyoung/Desktop/mothur/test.align)
```

### generate a count file
```
unique.seqs(fasta=/Users/jakobyoung/Desktop/mothur/test.align)
```

### generate a count table
```
count.seqs(name=/Users/jakobyoung/Desktop/mothur/test.names, fasta=/Users/jakobyoung/Desktop/mothur/test.unique.align)
```

### classify sequences to create tax file
```
classify.seqs(fasta=/Users/jakobyoung/Desktop/mothur/test.unique.align, count=/Users/jakobyoung/Desktop/mothur/test.count_table, reference=silva.nr_v138.align, taxonomy=silva.nr_v138.tax, processors=8)
```

### split your sequences by taxonomic level and cluster them into OTUs
```
cluster.split(fasta=/Users/jakobyoung/Desktop/mothur/test.unique.align, count=/Users/jakobyoung/Desktop/mothur/test.count_table, taxonomy=/Users/jakobyoung/Desktop/mothur/test.unique.taxonomy, taxlevel=4, processors=8)
```
* fasta: The refined alignment file (test.unique.pick.align).
* count: The refined count table (test.pick.count_table).
* taxonomy: The refined taxonomy file (test.unique.seed_v138.wang.pick.taxonomy).
* taxlevel=4: Specifies the taxonomic level at which to split sequences (Level 4 generally corresponds to the class level).
* processors=8: This specifies the number of processors to use for faster processing (adjust based on your system).

### assign taxonomy to the OTUs
```
classify.otu(list=/Users/jakobyoung/Desktop/mothur/test.unique.pick.opti_mcc.list, count=/Users/jakobyoung/Desktop/mothur/test.pick.count_table, taxonomy=/Users/jakobyoung/Desktop/mothur/test.unique.seed_v138.wang.pick.taxonomy, label=0.03)
```
* list: The .list file generated by the clustering step, in this case, test.unique.pick.opti_mcc.list. This file contains information on the OTUs formed during clustering.
* count: The .count_table file that keeps track of the abundance of sequences, test.pick.count_table.
* taxonomy: The .taxonomy file that contains the taxonomic classification of your sequences, test.unique.seed_v138.wang.pick.taxonomy.
* label=0.03: The OTU label, which corresponds to a 3% dissimilarity threshold, typically used for species-level OTUs.


### transfer to R for plotting:
```
library(ggplot2)
library(dplyr)

taxonomy_data <- read.table("/Users/jakobyoung/Desktop/mothur/test.unique.pick.opti_mcc.0.03.cons.taxonomy", header = TRUE, sep = "\t")

library(tidyr)
library(dplyr)
library(ggplot2)
library(stringr)

taxonomy_data <- taxonomy_data %>%
  separate(Taxonomy, into = c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species"), sep = ";", fill = "right")

taxonomy_data <- taxonomy_data %>%
  mutate(across(Kingdom:Species, ~ str_remove(., "\\(.*\\)")))

taxonomy_data <- taxonomy_data %>%
  mutate(across(Kingdom:Species, ~ str_replace(., "unclassified", "na")))

phylum_data <- taxonomy_data %>%
  group_by(Genus) %>%
  summarise(counts = sum(Size))

ggplot(phylum_data, aes(x = Genus, y = counts, fill = Genus)) +
  geom_bar(stat = "identity") +
  scale_y_log10() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title = "genus level community makeup", x = "genus", y = "count (log adjusted)") +
  theme_bw() +
  theme(legend.position = "none", axis.text.x = element_text(angle = 90, hjust = 1))
```



